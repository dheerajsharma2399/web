# You are Gemini 2.5 Pro — Build & Deploy the Sweet Shop Management System (Next.js + Supabase on Vercel)

**Goal:** Generate a complete, production‑ready full‑stack web app for a *Sweet Shop Management System* that **deploys directly to Vercel** and uses **Supabase** for **authentication, Postgres database, Row‑Level Security (RLS), and (optional) Storage**. Use **React via Next.js (App Router)** with TypeScript and a modern UI. Follow **TDD**. Output fully runnable code, schema, and policies.

---

## Platform & Stack (must‑use)

* **Hosting:** Vercel (Edge‑friendly where possible)
* **Frontend/Backend framework:** Next.js 15+ (App Router, TypeScript)
* **UI:** Tailwind CSS + shadcn/ui (Radix under the hood), responsive, dark mode
* **State/Data:** React Query or Server Actions (use React Query on the client; Server Actions for privileged ops)
* **Auth/DB:** Supabase (Auth, Postgres, RLS, optional Storage)
* **ORM/Client:** Supabase JS client (`@supabase/ssr` with cookie‑based auth helpers)
* **Validation:** Zod
* **Testing:**

  * API/Server: Jest + supertest (via route handler tests) or Next test utils
  * UI: Vitest + React Testing Library
  * E2E: Playwright (smoke: login → purchase flow → admin CRUD)
* **Tooling:** ESLint + Prettier, Husky + lint‑staged, dotenv, editorconfig
* **Docs:** Swagger (openapi.json generated by route schemas) + README (with **My AI Usage**)

> **Why Next.js?** Vercel‑native, first‑class API Route Handlers, edge runtime, and seamless cookie‑based Supabase auth with SSR/ISR.

---

## Roles & Capabilities

* **User**: register/login (email/password; OAuth optional), browse/search sweets, purchase (decrements stock), view own purchases.
* **Admin**: everything a user can + add/update/delete sweets, restock, hard delete.

Admin role is stored in **`profiles.role`** (`'user' | 'admin'`) and enforced via **RLS**.

---

## Database (Supabase Postgres) — SQL Schema

Create these with a **single SQL migration** (also provide split files `001_schema.sql`, `002_policies.sql`, `003_seed.sql`).

```sql
-- 001_schema.sql
-- Enable UUIDs
create extension if not exists "uuid-ossp";

-- Profiles: attaches role to Supabase auth.users
create table public.profiles (
  id uuid primary key references auth.users(id) on delete cascade,
  name text not null check (char_length(name) between 2 and 80),
  role text not null default 'user' check (role in ('user','admin')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create trigger trg_profiles_updated
before update on public.profiles
for each row execute procedure public.set_current_timestamp_on_update();

-- Utility trigger fn
create or replace function public.set_current_timestamp_on_update()
returns trigger language plpgsql as $$
begin new.updated_at = now(); return new; end; $$;

-- Sweets catalog
create table public.sweets (
  id uuid primary key default uuid_generate_v4(),
  name text not null unique,
  category text not null check (category in ('chocolate','candy','cookie','cake','pastry','other')),
  price_cents int not null check (price_cents >= 0),
  quantity int not null check (quantity >= 0),
  description text,
  image_url text,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);
create index idx_sweets_category on public.sweets(category);
create index idx_sweets_price on public.sweets(price_cents);
create trigger trg_sweets_updated
before update on public.sweets
for each row execute procedure public.set_current_timestamp_on_update();

-- Purchases (append‑only)
create table public.purchases (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null references auth.users(id) on delete cascade,
  sweet_id uuid not null references public.sweets(id) on delete restrict,
  quantity int not null check (quantity >= 1),
  unit_price_cents int not null check (unit_price_cents >= 0),
  total_cents int not null check (total_cents >= 0),
  created_at timestamptz not null default now()
);
create index idx_purchases_user_time on public.purchases(user_id, created_at desc);
create index idx_purchases_sweet on public.purchases(sweet_id);

-- Atomic purchase function (single‑statement guarantee)
create or replace function public.perform_purchase(p_user uuid, p_sweet uuid, p_qty int)
returns public.purchases
language plpgsql
as $$
declare v_price int; v_row public.purchases; v_updated sweets;
begin
  if p_qty < 1 then raise exception 'quantity must be >= 1'; end if;
  -- read current price
  select price_cents into v_price from public.sweets where id = p_sweet;
  if not found then raise exception 'sweet not found'; end if;
  -- atomic stock decrement if enough inventory
  update public.sweets
    set quantity = quantity - p_qty
  where id = p_sweet and quantity >= p_qty
  returning * into v_updated;
  if not found then raise exception 'insufficient_stock'; end if;
  insert into public.purchases(user_id, sweet_id, quantity, unit_price_cents, total_cents)
  values (p_user, p_sweet, p_qty, v_price, v_price * p_qty)
  returning * into v_row;
  return v_row;
end; $$;
```

### Row‑Level Security (RLS) Policies

```sql
-- 002_policies.sql
alter table public.profiles enable row level security;
alter table public.sweets enable row level security;
alter table public.purchases enable row level security;

-- Profiles: each user can see/update their own profile only
create policy "read own profile" on public.profiles for select
  using (auth.uid() = id);
create policy "update own profile" on public.profiles for update
  using (auth.uid() = id);

-- Sweets: anyone authed can read; only admins can write
create policy "read sweets" on public.sweets for select using (true);
create policy "admin manage sweets" on public.sweets for all
  using (exists (select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'))
  with check (exists (select 1 from public.profiles p where p.id = auth.uid() and p.role = 'admin'));

-- Purchases: users read/insert their own rows
create policy "insert own purchase" on public.purchases for insert
  with check (auth.uid() = user_id);
create policy "read own purchases" on public.purchases for select
  using (auth.uid() = user_id);
```

### Seed Data

```sql
-- 003_seed.sql
-- Create an admin profile for your account after signup (update the UUID accordingly)
-- insert into public.profiles (id, name, role) values ('<your-auth-user-uuid>','Admin','admin');

insert into public.sweets(name, category, price_cents, quantity, description)
values
 ('Dark Chocolate Bar','chocolate',299,50,'70% cocoa'),
 ('Gummy Bears','candy',199,200,'Assorted fruit'),
 ('Choco Chip Cookie','cookie',149,120,'Crispy edges'),
 ('Red Velvet Cake','cake',1999,5,'1 kg whole cake');
```

> **Note:** When a new user signs up, create a `profiles` row via RPC/trigger or server action; default role = `user`.

---

## API Design (Next.js Route Handlers under `/app/api`)

All responses are JSON with a common error shape:

```json
{ "error": { "code": "VALIDATION_ERROR" | "UNAUTHORIZED" | "FORBIDDEN" | "NOT_FOUND" | "CONFLICT", "message": "...", "details": [] } }
```

### Auth (handled by Supabase)

* Email/password sign‑up & sign‑in using Supabase Auth. Provide client helpers and server actions:

  * `POST /api/auth/register` → wraps Supabase signUp + profile insert
  * `POST /api/auth/login` → wraps signInWithPassword
  * `POST /api/auth/logout` → signs out (server action clears cookies)

### Sweets

* `GET    /api/sweets` — list w/ filters: `q`, `category`, `minPrice`, `maxPrice`, `page`, `limit`, `sort` (price|name|created\_at), `dir` (asc|desc)
* `GET    /api/sweets/[id]`
* `POST   /api/sweets` **admin** — create
* `PUT    /api/sweets/[id]` **admin** — update
* `DELETE /api/sweets/[id]` **admin** — delete
* `POST   /api/sweets/[id]/restock` **admin** — `{ quantity } ≥ 1` increments stock

### Purchases

* `POST /api/sweets/[id]/purchase` — `{ quantity } ≥ 1`; calls `public.perform_purchase(auth.uid(), id, qty)`
* `GET  /api/purchases/me` — current user’s purchases (paginated)

> **Security:** Prefer **RLS** to enforce row‑level access. For admin routes, verify admin via server‑side check using `getUser()` then selecting from `profiles`.

---

## Business Logic Rules

1. **Purchase** uses the **SQL function** `perform_purchase` to ensure atomic stock decrement + purchase insert.
2. **Restock** increments quantity; admin only.
3. **Delete Sweet** allowed regardless of existing purchases (purchases remain for history).
4. **Search** implements case‑insensitive `name` search and category/price filters with pagination.
5. **Auth** uses Supabase session cookies; server components/handlers access user via `createServerClient`.

---

## Project Structure

```
/ (repo root)
  apps/
    web/               # Next.js app
      app/
        (marketing)/
          page.tsx
        dashboard/     # protected area
          page.tsx
        admin/         # admin area
          sweets/
            page.tsx
          purchases/
            page.tsx
        api/
          auth/
            register/route.ts
            login/route.ts
            logout/route.ts
          sweets/route.ts               # GET (collection)
          sweets/[id]/route.ts          # GET/PUT/DELETE
          sweets/[id]/purchase/route.ts # POST
          sweets/[id]/restock/route.ts  # POST
          purchases/me/route.ts         # GET
      components/
        ui/* (shadcn)
        SweetCard.tsx
        SweetForm.tsx
        PurchaseDialog.tsx
        SearchBar.tsx
        Filters.tsx
        Navbar.tsx
      lib/
        supabase/server.ts   # server client w/ cookies
        supabase/client.ts   # browser client
        auth.ts              # getSession/getUser helpers
        validations.ts       # zod schemas
        pagination.ts
      hooks/
        usePagination.ts
      providers/
        query-provider.tsx   # React Query
        theme-provider.tsx
      styles/globals.css
      middleware.ts          # protect routes via Supabase session
      package.json
      next.config.mjs
      tailwind.config.ts
      postcss.config.js
      tsconfig.json
      .env.example
      README.md
  supabase/
    migrations/
      001_schema.sql
      002_policies.sql
      003_seed.sql
  package.json
  turbo.json (optional)      # if using Turborepo
  README.md (root)
```

---

## Core Files — Behaviors (high level)

* **`lib/supabase/server.ts`**: `createServerClient(supabaseUrl, supabaseAnonKey, { cookies })` helper for Route Handlers/Server Components.
* **`lib/supabase/client.ts`**: browser client for hooks & React Query.
* **`middleware.ts`**: gate `/dashboard` and `/admin` paths; redirect to `/login` if no session.
* **API route handlers** implement validation with Zod; read user with `serverClient.auth.getUser()`; for admin routes, check `profiles.role = 'admin'`.
* **UI**:

  * Public home lists sweets with search/filters.
  * Purchase modal handles qty; disables if stock 0; optimistic update.
  * Admin screens for CRUD + restock (forms with React Hook Form + Zod).

---

## Validation Schemas (Zod)

* `AuthRegister`: email, password (≥8), name
* `AuthLogin`: email, password
* `SweetCreate/Update`: name, category, price\_cents (int≥0), quantity (int≥0), description?, image\_url?
* `Purchase`: quantity≥1
* Query: `q, category, minPrice, maxPrice, page, limit, sort, dir`

---

## Testing Plan

* **Server**: route handlers (unit + integration with local Supabase test instance or mocked client); purchase atomicity asserted by expecting `insufficient_stock` error when stock too low.
* **Client**: components render; form validation; protected routes; purchase flow.
* **E2E (Playwright):** Sign up → auto profile create → admin promote (seed) → create sweet → user purchase.

---

## Deployment (Vercel + Supabase)

1. **Create Supabase project** → get `PROJECT_URL` and keys (Anon & Service Role).
2. **Run migrations** in Supabase SQL editor (`001_schema.sql`, `002_policies.sql`, `003_seed.sql`).
3. **Environment variables** (Vercel Project → Settings → Environment):

   * `NEXT_PUBLIC_SUPABASE_URL=<your-supabase-url>`
   * `NEXT_PUBLIC_SUPABASE_ANON_KEY=<your-anon-key>`
   * `SUPABASE_SERVICE_ROLE_KEY=<your-service-role-key>` *(server only)*
   * Optional: `NEXTAUTH_SECRET` not needed; we rely on Supabase cookies.
4. **Vercel**: Import GitHub repo → set env vars → deploy.
5. **Edge runtime**: mark light read routes as `export const runtime = 'edge'` (optional). Server actions use Node runtime.
6. **Admin**: after your first sign‑up, set your profile role to `admin` via SQL or an admin screen guarded by service role on first run.

---

## AI Usage (README requirement)

Add a **My AI Usage** section describing prompts/tools (Gemini, etc.), which files were AI‑generated vs. curated.

---

## Deliverables Gemini Must Output

Produce **complete files** as code blocks with proper paths so the project is copy‑pasta ready:

1. **Next.js app** under `apps/web` with all routes, components, providers, configs, and tests.
2. **Supabase SQL migrations** under `supabase/migrations` (schema, policies, seed).
3. **Environment templates** (`.env.example`) and README with exact run/deploy steps.
4. **OpenAPI spec** (`openapi.json`) covering the REST endpoints you expose (auth wrappers, sweets, purchases).
5. **Playwright config and a minimal e2e test**.

Render files in logical order (migrations → backend API routes → lib → UI pages/components → tests → configs → README). **No pseudocode**; ensure code compiles.

---

## Acceptance Criteria

* Works on **Vercel + Supabase** with only env vars and running migrations.
* Auth via Supabase; sessions persist via cookies; RLS enforced.
* Admin CRUD + restock; user browse/search/purchase; atomic purchase function.
* Modern, responsive UI with loading/empty/error states and toasts.
* Tests for critical flows; basic e2e passes.

---

## Final Instruction

**Generate all required files and code now**, with exact file headers like:

```
// apps/web/app/api/sweets/[id]/purchase/route.ts
<code here>
```

Focus on runnable, production‑grade code and clear README instructions for Vercel + Supabase.
